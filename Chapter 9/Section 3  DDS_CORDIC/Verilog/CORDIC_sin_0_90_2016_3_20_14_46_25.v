/***********************************************
Module Name:   CORDIC_sin_0_90_frame
Feature:       Approx. sin function by CORDIC
               Frame only for calling by generater 
               (DO NOT modify the file)
               to create the .v file
               An example for the book
Coder:         Garfield
Organization:  xxxx Group, Department of Architecture
------------------------------------------------------
Input ports:   clk: System clock
               Reset: System reset
               address: angle value displayed by address
                        (0 for 0 degree, maximum for 90 degree)
Output Ports:  vlaue: DDS output value, signed
------------------------------------------------------
History:
03-19-2016: First Version by Garfield
03-19-2016: Verified by CORDIC_sin_0_90_test
***********************************************/

module CORDIC_sin_0_90
//definition parameters
//Application part: Insert parameters(DO NOT REMOVE!)
//Below code/s was/were generated by the application
#(parameter ADDRESS_WIDTH = 8,
//Bit width for phase counter and step 
parameter INTERNAL_VALUE_WIDTH = 9,
//Internal value's bit width, internal one for calculate 
parameter VALUE_WIDTH = 8 )
//Output value's bit width//Above code/s was/were generated by the application
  ( 
    input CLK,
    input RESET,
    input[ADDRESS_WIDTH - 1 - 1: 0] address,
    output reg[VALUE_WIDTH - 1 - 1 : 0] value
  );

//Defination for Varables in the module
reg [ADDRESS_WIDTH - 2 - 1: 0] intra_address;
//definition wire varables to connect the CORDIC elements
//Application part: Insert wire varables (DO NOT REMOVE!)
//Below code/s was/were generated by the application
//Connetion wires between CORDIC element modules
wire[9 : 0] x[7 :1];
wire[9 : 0] y[7 :1];
wire[6 : 0] z[7 :1];
//Connect points between lines
//Above code/s was/were generated by the application

//Insert CORDIC element modules
//Application part: Insert CORDIC element modules (DO NOT REMOVE!)
//Below code/s was/were generated by the application
CORDIC_elemet #(.ADDRESS_WIDTH(6), .VALUE_WIDTH(9), .e_k(32), .ORDER(0))
    cor0(
        .CLK(CLK), .RESET(RESET),
        .x_k({1'b0, 9'd310}), .y_k({1'b0,9'h0}), .z_k({1'b0,intra_address}),
        .x_k1(x[1]),  .y_k1(y[1]),   .z_k1(z[1]));

 CORDIC_elemet #(.ADDRESS_WIDTH(6),.VALUE_WIDTH(9), .e_k(19), .ORDER(1))
      cor1(
        .CLK(CLK), .RESET(RESET),
        .x_k(x[1]),.y_k(y[1]),.z_k(z[1]),
        .x_k1(x[2]), .y_k1(y[2]), .z_k1(z[2]));

 CORDIC_elemet #(.ADDRESS_WIDTH(6),.VALUE_WIDTH(9), .e_k(10), .ORDER(2))
      cor2(
        .CLK(CLK), .RESET(RESET),
        .x_k(x[2]),.y_k(y[2]),.z_k(z[2]),
        .x_k1(x[3]), .y_k1(y[3]), .z_k1(z[3]));

 CORDIC_elemet #(.ADDRESS_WIDTH(6),.VALUE_WIDTH(9), .e_k(5), .ORDER(3))
      cor3(
        .CLK(CLK), .RESET(RESET),
        .x_k(x[3]),.y_k(y[3]),.z_k(z[3]),
        .x_k1(x[4]), .y_k1(y[4]), .z_k1(z[4]));

 CORDIC_elemet #(.ADDRESS_WIDTH(6),.VALUE_WIDTH(9), .e_k(3), .ORDER(4))
      cor4(
        .CLK(CLK), .RESET(RESET),
        .x_k(x[4]),.y_k(y[4]),.z_k(z[4]),
        .x_k1(x[5]), .y_k1(y[5]), .z_k1(z[5]));

 CORDIC_elemet #(.ADDRESS_WIDTH(6),.VALUE_WIDTH(9), .e_k(1), .ORDER(5))
      cor5(
        .CLK(CLK), .RESET(RESET),
        .x_k(x[5]),.y_k(y[5]),.z_k(z[5]),
        .x_k1(x[6]), .y_k1(y[6]), .z_k1(z[6]));

 CORDIC_elemet #(.ADDRESS_WIDTH(6),.VALUE_WIDTH(9), .e_k(1), .ORDER(6))
      cor6(
        .CLK(CLK), .RESET(RESET),
        .x_k(x[6]),.y_k(y[6]),.z_k(z[6]),
        .x_k1(x[7]), .y_k1(y[7]), .z_k1(z[7]));

 //Above code/s was/were generated by the application

//Intra address operation
always @ (posedge CLK or negedge RESET)
//Address adjust: 90 degree operation
begin
    if (!RESET)
    //Reset enable
    begin
        intra_address <= {(ADDRESS_WIDTH - 1){1'b0}};
    end
    else
    begin
        if (address[ADDRESS_WIDTH - 1 -1])
        //90 degree
        begin
            intra_address <= {(ADDRESS_WIDTH - 2){1'b1}};
            //To 111...111
        end
        else
        begin
            intra_address <= address[ADDRESS_WIDTH - 1 - 2: 0]; 
            //Keep original value       	
        end
    end
end
always @(posedge CLK or negedge RESET)
begin
    if (!RESET)
    begin
        value <= {(VALUE_WIDTH - 1){1'b0}};
    end
    else
    begin
    //Truncate for output
    //Application part: Insert Truncation (DO NOT REMOVE!)
//Below code/s was/were generated by the application
        value <= y[7][8: 2];
//Above code/s was/were generated by the application
    end
end

endmodule
